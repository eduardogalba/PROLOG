section_env([file_top_section,pragmas([]),paper_opts(1,afourpaper),coversec([],[],[[string_esc("Eduardo Gil Alba, z170238")]],[],nop,nop,[]),level(0)],global_label("PROLOG: Practica 1"),[string_esc("PROLOG: Practica 1")],[show_toc(subparts),section_env([unnumbered,level(1),subfile(intro)],global_label("code"),string_esc("code"),[[],[],[section_env([with_parent,level(2)],local_label("Usage and interface"),string_esc("Usage and interface"),cartouche(itemize_env(bullet,[[item([]),bf([string_esc("Library usage"),string_esc(":")]),linebreak,tt(string_esc(":- use_module(/home/lumbalu/PROLOG/repo/PROLOG/Practica 1/code.pl)."))],[item([]),bf([string_esc("Exports"),string_esc(":")]),linebreak,itemize_env(minus,[[[item([]),em([string_esc("Predicates"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("0"),string_esc("mylength/2"),string_esc("mylength/2")),string_esc(", ")],[idx_env(use,code,localnum_label("1"),string_esc("get/3"),string_esc("get/3")),string_esc(", ")],[idx_env(use,code,localnum_label("2"),string_esc("myappend/3"),string_esc("myappend/3")),string_esc(", ")],[idx_env(use,code,localnum_label("3"),string_esc("f/2"),string_esc("f/2")),string_esc(", ")],[idx_env(use,code,localnum_label("4"),string_esc("equal/2"),string_esc("equal/2")),string_esc(", ")],[idx_env(use,code,localnum_label("5"),string_esc("plus/3"),string_esc("plus/3")),string_esc(", ")],[idx_env(use,code,localnum_label("6"),string_esc("minus/3"),string_esc("minus/3")),string_esc(", ")],[idx_env(use,code,localnum_label("7"),string_esc("less/2"),string_esc("less/2")),string_esc(", ")],[idx_env(use,code,localnum_label("8"),string_esc("div/3"),string_esc("div/3")),string_esc(", ")],[idx_env(use,code,localnum_label("9"),string_esc("surface_acc/2"),string_esc("surface_acc/2")),string_esc(", ")],[idx_env(use,code,localnum_label("10"),string_esc("h_line/3"),string_esc("h_line/3")),string_esc(", ")],[idx_env(use,code,localnum_label("11"),string_esc("v_line/3"),string_esc("v_line/3")),string_esc(", ")],[idx_env(use,code,localnum_label("12"),string_esc("v_lines/2"),string_esc("v_lines/2")),string_esc(", ")],[idx_env(use,code,localnum_label("13"),string_esc("v_lines_aux/3"),string_esc("v_lines_aux/3")),string_esc(", ")],[idx_env(use,code,localnum_label("14"),string_esc("h_sum/2"),string_esc("h_sum/2")),string_esc(", ")],[idx_env(use,code,localnum_label("15"),string_esc("total_charge/2"),string_esc("total_charge/2")),string_esc(", ")],[idx_env(use,code,localnum_label("16"),string_esc("total_charge_aux/2"),string_esc("total_charge_aux/2")),string_esc(", ")],[idx_env(use,code,localnum_label("17"),string_esc("total_cells/2"),string_esc("total_cells/2")),string_esc(", ")],[idx_env(use,code,localnum_label("18"),string_esc("average_charge/2"),string_esc("average_charge/2")),string_esc(".")]],raw_nl]],nop,[item([]),em([string_esc("Properties"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("19"),string_esc("author_data/4"),string_esc("author_data/4")),string_esc(", ")],[idx_env(use,code,localnum_label("20"),string_esc("charge/1"),string_esc("charge/1")),string_esc(", ")],[idx_env(use,code,localnum_label("21"),string_esc("my_list/1"),string_esc("my_list/1")),string_esc(", ")],[idx_env(use,code,localnum_label("22"),string_esc("nat_num/1"),string_esc("nat_num/1")),string_esc(", ")],[idx_env(use,code,localnum_label("23"),string_esc("basic_surface/1"),string_esc("basic_surface/1")),string_esc(", ")],[idx_env(use,code,localnum_label("24"),string_esc("surface/1"),string_esc("surface/1")),string_esc(".")]],raw_nl]],nop,nop,nop],nop])],nop,nop,nop,nop]))),[],[],section_env([with_parent,level(2)],local_label("Documentation on exports"),string_esc("Documentation on exports"),[[defpred(local_label("author_data/4"),prop,"PROPERTY",author_data/4,[],[[string_esc("Defines authors in Deliverit system. It is defined as: "),env_(verbatim,[raw_string("author_data('Gil','Alba','Eduardo','Z170238').
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("author_data(Surname1,Surname2,Name,ID)")),string_esc([])],raw_nl],[var([string_esc("Surname1")]),string_esc(" "),string_esc("is your first surname."),p([]),var([string_esc("Surname2")]),string_esc(" "),string_esc("is your second surname."),p([]),var([string_esc("Name")]),string_esc(" "),string_esc("is your name."),p([]),var([string_esc("ID")]),string_esc(" "),string_esc("is university identifier.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("charge/1"),prop,"PROPERTY",charge/1,[],[[string_esc("Defines possible cell charge values. "),env_(verbatim,[raw_string("charge(+++++++).
charge(++++++).
charge(+++++).
charge(++++).
charge(+++).
charge(++).
charge(+).
charge(0).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("charge(C)")),string_esc([])],raw_nl],[var([string_esc("C")]),string_esc(" "),string_esc("is cell charge value")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("my_list/1"),prop,"PROPERTY",my_list/1,[],[[string_esc("Defines a list according to the internal representation "),tt([string_esc("[Head|Tail]")]),string_esc(" "),string_esc("in Prolog, which will stores cell charges values. "),env_(verbatim,[raw_string("my_list([H]) :-
    charge(H).
my_list([H|T]) :-
    charge(H),
    my_list(T).
")]),string_esc(" "),p([]),string_esc("The predicate "),idx_env(use,pred,localnum_label("25"),[string_esc("list/1")],[string_esc("list/1")]),string_esc(" "),string_esc("is called recursively, checking that all elements are charges and that it is a list structure. ")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("my_list(L)")),string_esc([])],raw_nl],[var([string_esc("L")]),string_esc(" "),string_esc("is a list with charge cell values.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("mylength/2"),pred,"PREDICATE",mylength/2,[],[[string_esc("Calculates the size of a list. "),env_(verbatim,[raw_string("mylength([],0).
mylength([_1|T],s(N)) :-
    mylength(T,N).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("mylength(L,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("L")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("26"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("27"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("get/3"),pred,"PREDICATE",get/3,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("get(L,I,E)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("L")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("28"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("I")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("29"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("E")]),string_esc(" "),string_esc("is cell charge value")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("30"),string_esc("charge/1"),string_esc("charge/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("myappend/3"),pred,"PREDICATE",myappend/3,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("myappend(L1,L2,R)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("L1")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("31"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("L2")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("32"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("R")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("33"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("f/2"),pred,"PREDICATE",f/2,[],[[],[[defassrt(check,[],"Usage 1:",[[string_esc([]),tt(string_esc("f(C,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is cell charge value")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("34"),string_esc("charge/1"),string_esc("charge/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("35"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[])),defassrt(check,[],"Usage 2:",[[string_esc([]),tt(string_esc("f(N1,N2)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("N1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("36"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("37"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("nat_num/1"),prop,"PROPERTY",nat_num/1,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("nat_num(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a natural number.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("equal/2"),pred,"PREDICATE",equal/2,[],[[string_esc("Defines equality operator "),idx_env(use,op,localnum_label("38"),[string_esc("==")],[string_esc("==")]),string_esc(" "),string_esc("between two natural numbers in Peano notation. "),env_(verbatim,[raw_string("equal(0,0).
equal(s(N),s(N)) :-
    nat_num(N),
    equal(N,N).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("equal(N1,N2)")),string_esc([])],raw_nl],[idx_env(use,pred,localnum_label("39"),[string_esc("equal/2")],[string_esc("equal/2")]),string_esc(" "),string_esc("will be true if both numbers are equal")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("N1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("40"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("41"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("plus/3"),pred,"PREDICATE",plus/3,[],[[string_esc("Defines sum operator "),idx_env(use,op,localnum_label("42"),[string_esc("+")],[string_esc("+")]),string_esc(" "),string_esc("between two natural numbers in Peano notation. "),env_(verbatim,[raw_string("plus(0,Y,Y) :-
    nat_num(Y).
plus(s(X),Y,s(Z)) :-
    plus(X,Y,Z).
")]),string_esc(" "),p([]),string_esc("In case base, the sum of any number with 0, is the same number. The recursive call decrements the value of the first operand to 0, reaching case base, which assigns the second operand to the result and, when returning, increments the result as many times as recursive calls have been made. ")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("plus(Op1,Op2,Res)")),string_esc([])],raw_nl],[var([string_esc("Res")]),string_esc(" "),string_esc("is the sum of "),var([string_esc("Op1")]),string_esc(" "),string_esc("and "),var([string_esc("Op2")])],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Op2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("43"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Op1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("44"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Res")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("45"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("minus/3"),pred,"PREDICATE",minus/3,[],[[string_esc("Defines subtraction operator "),idx_env(use,op,localnum_label("46"),[string_esc("-")],[string_esc("-")]),string_esc(" "),string_esc("between two natural numbers in Peano notation, using "),idx_env(use,pred,localnum_label("47"),[string_esc("plus/3")],[string_esc("plus/3")]),string_esc(". "),env_(verbatim,[raw_string("minus(X,Y,Z) :-
    plus(Z,Y,X).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("minus(Op2,Op1,Res)")),string_esc([])],raw_nl],[var([string_esc("Res")]),string_esc(" "),string_esc("is the difference between "),var([string_esc("Op2")]),string_esc(" "),string_esc("and "),var([string_esc("Op1")])],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Op2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("48"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Op1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("49"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Res")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("50"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("less/2"),pred,"PREDICATE",less/2,[],[[string_esc("Defines less than "),idx_env(use,op,localnum_label("51"),[string_esc(">")],[string_esc(">")]),string_esc(" "),string_esc("operator between two natural numbers in Peano notation. "),env_(verbatim,[raw_string("less(0,s(X)) :-
    nat_num(X).
less(s(X),s(Y)) :-
    less(X,Y).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("less(N,M)")),string_esc([])],raw_nl],[idx_env(use,pred,localnum_label("52"),[string_esc("less/2")],[string_esc("less/2")]),string_esc(" "),string_esc("will be true if "),var([string_esc("N")]),string_esc(" "),string_esc("less than "),var([string_esc("M")])],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("53"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("M")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("54"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("div/3"),pred,"PREDICATE",div/3,[],[[string_esc("Defines division "),idx_env(use,op,localnum_label("55"),[string_esc("/")],[string_esc("/")]),string_esc(" "),string_esc("between two natural numbers in Peano notation. "),env_(verbatim,[raw_string("div(0,_1,0).
div(X,Y,s(0)) :-
    minus(X,Y,Z),
    less(Z,Y).
div(X,Y,s(Q)) :-
    minus(X,Y,Z),
    div(Z,Y,Q).
")]),string_esc(" "),p([]),string_esc("Division is viewed as successive subtractions from the dividend until it becomes 0 or the remainder. ")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("div(Dividend,Divisor,Quotient)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Dividend")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("56"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Divisor")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("57"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Quotient")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("58"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("basic_surface/1"),prop,"PROPERTY",basic_surface/1,[],[[string_esc("Defines a surface of cell charges represented by a list of lists. Internal representation will be "),tt([string_esc("[List | [Lists]]")]),string_esc(". "),p([]),env_(note,[string_esc(" "),bf([string_esc("Note:")]),string_esc(" "),idx_env(use,pred,localnum_label("59"),[string_esc("basic_surface/1")],[string_esc("basic_surface/1")]),string_esc(" "),string_esc("must contains at least one non-empty horizontal line. ")]),string_esc(" "),p([]),string_esc("It is defined as: "),env_(verbatim,[raw_string("basic_surface([L]) :-
    my_list(L).
basic_surface([L|S2]) :-
    my_list(L),
    basic_surface(S2).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("basic_surface(CellList)")),string_esc([])],raw_nl],[var([string_esc("CellList")]),string_esc(" "),string_esc("is a list of lists with charged cells.")],assrtprops([],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("basic_surface(S)")),string_esc([])],raw_nl],[string_esc("Cannot have blank lines.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("60"),string_esc("S=[[0,++],[],[+,+++]]"),string_esc("S=[[0,++],[],[+,+++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("61"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("basic_surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("62"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("basic_surface(S)")),string_esc([])],raw_nl],[string_esc("Line contents must have cell charge values.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("63"),string_esc("S=[[0,1],[+++,+],[+,++]]"),string_esc("S=[[0,1],[+++,+],[+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("64"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("basic_surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("65"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("basic_surface(S)")),string_esc([])],raw_nl],[string_esc("Cannot be an empty list.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("66"),string_esc("S=[]"),string_esc("S=[]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("67"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("basic_surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("68"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("basic_surface(S)")),string_esc([])],raw_nl],[string_esc("Cannot be a list with a empty sublist")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("69"),string_esc("S=[[]]"),string_esc("S=[[]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("70"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("basic_surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("71"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("basic_surface(S)")),string_esc([])],raw_nl],[string_esc("Line must contain at least one cell.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("72"),string_esc("S=[[_109491]]"),string_esc("S=[[_109491]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("73"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("basic_surface(S)")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("74"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("basic_surface(S)")),string_esc([])],raw_nl],[string_esc("Lines could have different sizes.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("75"),string_esc("S=[[_109358,_109360,_109362],[_109366,_109368],[_109372]]"),string_esc("S=[[_109358,_109360,_109362],[_109366,_109368],[_109372]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("76"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("basic_surface(S)")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("77"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("surface/1"),prop,"PROPERTY",surface/1,[],[[string_esc("Defines a surface of charged cells, represented by a cell charge matrix. "),env_(note,[string_esc(" "),bf([string_esc("Note:")]),string_esc(" "),idx_env(use,pred,localnum_label("78"),[string_esc("surface/1")],[string_esc("surface/1")]),string_esc(" "),string_esc("must contains at least one non-empty horizontal line. ")]),string_esc(" "),p([]),string_esc("It is defined as: "),env_(verbatim,[raw_string("surface([L|L2]) :-
    basic_surface([L|L2]),
    mylength(L,Tam),
    surface_acc([L|L2],Tam).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("surface(CellMatrix)")),string_esc([])],raw_nl],[var([string_esc("CellMatrix")]),string_esc(" "),string_esc("is a matrix with charged cells.")],assrtprops([],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("surface(S)")),string_esc([])],raw_nl],[string_esc("Call surface correctly.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("79"),string_esc("S=[[++,+++],[0,+],[+,++]]"),string_esc("S=[[++,+++],[0,+],[+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("80"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("surface(S)")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("81"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("surface(S)")),string_esc([])],raw_nl],[string_esc("Cannot have blank lines.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("82"),string_esc("S=[[0,++],[],[+,+++]]"),string_esc("S=[[0,++],[],[+,+++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("83"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("84"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("surface(S)")),string_esc([])],raw_nl],[string_esc("Line contents must have cell charge values.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("85"),string_esc("S=[[+++,1],[+++,+],[+,++]]"),string_esc("S=[[+++,1],[+++,+],[+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("86"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("87"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("surface(S)")),string_esc([])],raw_nl],[string_esc("Cannot be a list with empty sublist.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("88"),string_esc("S=[[]]"),string_esc("S=[[]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("89"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("90"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("surface(S)")),string_esc([])],raw_nl],[string_esc("Line must contain at least one cell.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("91"),string_esc("S=[[_25226]]"),string_esc("S=[[_25226]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("92"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("surface(S)")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("93"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("surface(S)")),string_esc([])],raw_nl],[string_esc("Lines must have same length.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("94"),string_esc("S=[[_25099,_25101,_25103],[_25107,_25109],[_25113,_25115,_25117]]"),string_esc("S=[[_25099,_25101,_25103],[_25107,_25109],[_25113,_25115,_25117]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("95"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("surface(S)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("96"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("surface_acc/2"),pred,"PREDICATE",surface_acc/2,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("surface_acc(S,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("97"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("98"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("h_line/3"),pred,"PREDICATE",h_line/3,[],[[string_esc("Extracts a specific horizontal line from surface "),env_(verbatim,[raw_string("h_line([L],s(0),L).
h_line(S,N,C) :-
    get(S,N,C),
    surface(S).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("h_line(S,I,R)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("99"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("I")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("100"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("R")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("101"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])]],raw_nl],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("h_line(S,I,R)")),string_esc([])],raw_nl],[string_esc("Get horizontal line correctly(1).")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("102"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("103"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("104"),string_esc("I=s(0)"),string_esc("I=s(0)"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("105"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("106"),string_esc("R=[0,+,++]"),string_esc("R=[0,+,++]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("107"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("h_line(S,I,R)")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("108"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("h_line(S,I,R)")),string_esc([])],raw_nl],[string_esc("Get horizontal line correctly(2).")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("109"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("110"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("111"),string_esc("I=s(s(0))"),string_esc("I=s(s(0))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("112"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("113"),string_esc("R=[+++,++++,+++++]"),string_esc("R=[+++,++++,+++++]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("114"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("h_line(S,I,R)")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("115"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("h_line(S,I,R)")),string_esc([])],raw_nl],[string_esc("Get horizontal line index correctly.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("116"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("117"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("118"),string_esc("R=[+++,++++,+++++]"),string_esc("R=[+++,++++,+++++]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("119"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("120"),string_esc("I=s(s(0))"),string_esc("I=s(s(0))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("121"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("All the calls of the form "),var([string_esc("h_line(S,I,R)")]),string_esc(" "),string_esc("do not fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("122"),string_esc("not_fails/1"),string_esc("not_fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("h_line(Arg1,I,Arg3)")),string_esc([])],raw_nl],[string_esc("Get non-existing horizontal line(1)")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("123"),string_esc("I=0"),string_esc("I=0"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("124"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("h_line(Arg1,I,Arg3)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("125"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("h_line(S,I,Arg3)")),string_esc([])],raw_nl],[string_esc("Get non-existing horizontal line(2).")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("126"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"),string_esc("S=[[0,+,++],[+++,++++,+++++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("127"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("128"),string_esc("I=s(s(s(0)))"),string_esc("I=s(s(s(0)))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("129"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("h_line(S,I,Arg3)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("130"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("h_line(S,Arg2,Arg3)")),string_esc([])],raw_nl],[string_esc("Cannot be an empty surface.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("131"),string_esc("S=[]"),string_esc("S=[]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("132"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("h_line(S,Arg2,Arg3)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("133"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("v_line/3"),pred,"PREDICATE",v_line/3,[],[[string_esc("Extracts a specific vertical line from surface "),env_(verbatim,[raw_string("v_line([Fila],Indice,[Elemento]) :-
    get(Fila,Indice,Elemento).
v_line([Fila|Filas],Indice,[Elemento|Columna]) :-
    get(Fila,Indice,Elemento),
    v_line(Filas,Indice,Columna).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("v_line(S,I,C)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("134"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("I")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("135"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("136"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])]],raw_nl],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_line(S,I,C)")),string_esc([])],raw_nl],[string_esc("Get column correctly")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("137"),string_esc("S=[[0,+,++],[0,+,++]]"),string_esc("S=[[0,+,++],[0,+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("138"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("139"),string_esc("I=s(s(0))"),string_esc("I=s(s(0))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("140"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("141"),string_esc("C=[+,+]"),string_esc("C=[+,+]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("142"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_line(S,I,C)")),string_esc([])],raw_nl],[string_esc("Get index from column correctly")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("143"),string_esc("S=[[0,+,++],[0,+,++]]"),string_esc("S=[[0,+,++],[0,+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("144"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("145"),string_esc("C=[+,+]"),string_esc("C=[+,+]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("146"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("147"),string_esc("I=s(s(0))"),string_esc("I=s(s(0))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("148"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_line(S,I,Arg3)")),string_esc([])],raw_nl],[string_esc("Get non-existing vertical line(1)")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("149"),string_esc("S=[[0,+,++],[0,+,++]]"),string_esc("S=[[0,+,++],[0,+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("150"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("151"),string_esc("I=0"),string_esc("I=0"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("152"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("v_line(S,I,Arg3)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("153"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_line(S,I,Arg3)")),string_esc([])],raw_nl],[string_esc("Get non-existing vertical line(2)")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("154"),string_esc("S=[[0,+,++],[0,+,++]]"),string_esc("S=[[0,+,++],[0,+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("155"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("156"),string_esc("I=s(s(s(s(0))))"),string_esc("I=s(s(s(s(0))))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("157"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("v_line(S,I,Arg3)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("158"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_line(S,Arg2,Arg3)")),string_esc([])],raw_nl],[string_esc("Cannot be an empty surface.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("159"),string_esc("S=[]"),string_esc("S=[]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("160"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("v_line(S,Arg2,Arg3)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("161"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_line(S,Arg2,Arg3)")),string_esc([])],raw_nl],[string_esc("Surface must have at least one cell")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("162"),string_esc("S=[[]]"),string_esc("S=[[]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("163"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("v_line(S,Arg2,Arg3)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("164"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("v_lines/2"),pred,"PREDICATE",v_lines/2,[],[[string_esc("Extracts all vertical lines. "),env_(verbatim,[raw_string("v_lines([L],L).
v_lines([L|S2],C) :-
    mylength(L,Tam),
    v_lines_aux([L|S2],Tam,C).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("v_lines(S,C)")),string_esc([])],raw_nl],[],assrtprops([],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("165"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold upon exit:"))],[[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("166"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])]],raw_nl],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_lines(S,C)")),string_esc([])],raw_nl],[string_esc("Test with square matrix")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("167"),string_esc("S=[[0,+,++],[0,+,++],[0,+,++]]"),string_esc("S=[[0,+,++],[0,+,++],[0,+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("168"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("169"),string_esc("C=[[0,0,0],[+,+,+],[++,++,++]]"),string_esc("C=[[0,0,0],[+,+,+],[++,++,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("170"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("v_lines(S,C)")),string_esc([])],raw_nl],[string_esc("Test with rectangular matrix")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("171"),string_esc("S=[[0,+,++],[0,+,++]]"),string_esc("S=[[0,+,++],[0,+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("172"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("173"),string_esc("C=[[0,0],[+,+],[++,++]]"),string_esc("C=[[0,0],[+,+],[++,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("174"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[]))]]]]),sp("1"),raw_nl],[defpred(local_label("v_lines_aux/3"),pred,"PREDICATE",v_lines_aux/3,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("v_lines_aux(S,T,C)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("175"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("176"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("177"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("h_sum/2"),pred,"PREDICATE",h_sum/2,[],[[string_esc("Sum elements of a horizontal line. "),env_(verbatim,[raw_string("h_sum([C],N) :-
    f(C,N).
h_sum([H|T],Suma) :-
    h_sum(T,SumaResto),
    f(H,N),
    plus(N,SumaResto,Suma).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("h_sum(R,T)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("R")]),string_esc(" "),string_esc("is a list with charge cell values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("178"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("179"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("total_charge/2"),pred,"PREDICATE",total_charge/2,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("total_charge(S,T)")),string_esc([])],raw_nl],[var([string_esc("T")]),string_esc(" "),string_esc("is the sum of all elements in a surface.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("180"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("181"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("total_charge([[0,+],[++,+++],[++++,+++++]],T)")),string_esc([])],raw_nl],[],assrtprops([],[],[[item([]),em(string_esc("The following properties should hold upon exit:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("182"),string_esc("T=s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))"),string_esc("T=s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0)))))))))))))))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("183"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("total_charge(S,Arg2)")),string_esc([])],raw_nl],[],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("184"),string_esc("S=[[0,+],[++,3],[++++,+++++]]"),string_esc("S=[[0,+],[++,3],[++++,+++++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("185"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("total_charge(S,Arg2)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("186"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("total_charge(S,Arg2)")),string_esc([])],raw_nl],[],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("187"),string_esc("S=[[]]"),string_esc("S=[[]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("188"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("total_charge(S,Arg2)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("189"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("total_charge(S,Arg2)")),string_esc([])],raw_nl],[],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("190"),string_esc("S=[[_111260,_111262,_111264],[_111268,_111270],[_111274]]"),string_esc("S=[[_111260,_111262,_111264],[_111268,_111270],[_111274]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("191"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("total_charge(S,Arg2)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("192"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl],[defpred(local_label("total_charge_aux/2"),pred,"PREDICATE",total_charge_aux/2,[],[[],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("total_charge_aux(S,T)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("193"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("194"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("total_cells/2"),pred,"PREDICATE",total_cells/2,[],[[string_esc("Calculates the number of elements of a surface. "),env_(verbatim,[raw_string("total_cells([L],N) :-
    mylength(L,N).
total_cells([L|S2],Total) :-
    total_cells(S2,TotalResto),
    mylength(L,Esta),
    plus(Esta,TotalResto,Total).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("total_cells(S,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("195"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("196"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("average_charge/2"),pred,"PREDICATE",average_charge/2,[],[[string_esc("Calculates average cell charge value from surface. "),env_(verbatim,[raw_string("average_charge([[]],_1).
average_charge(S,A) :-
    total_charge(S,M),
    total_cells(S,T),
    div(M,T,A).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("average_charge(S,A)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a matrix with charged cells.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("197"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("A")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("198"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))],[[[],[]],[]],[[raw_nl,bf(string_esc("Other properties:")),string_esc(" "),linebreak],[defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("average_charge(S,A)")),string_esc([])],raw_nl],[string_esc("Get average charge correctly(1).")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("199"),string_esc("S=[[++,++],[++,++],[++,++]]"),string_esc("S=[[++,++],[++,++],[++,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("200"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("201"),string_esc("A=s(s(0))"),string_esc("A=s(s(0))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("202"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("average_charge(S,A)")),string_esc([])],raw_nl],[string_esc("Get average charge correctly(2).")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("203"),string_esc("S=[[+,++],[+,++],[+,++]]"),string_esc("S=[[+,++],[+,++],[+,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("204"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[[linebreak,em(string_esc("then the following properties should hold upon exit:")),raw_nl],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("205"),string_esc("A=s(0)"),string_esc("A=s(0)"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("206"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("average_charge(S,A)")),string_esc([])],raw_nl],[string_esc("Round to lower number.")],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("207"),string_esc("S=[[++,+++,+++++++],[+,++,++],[++,+++,+],[++,++,++]]"),string_esc("S=[[++,+++,+++++++],[+,++,++],[++,+++,+],[++,++,++]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("208"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])],[linebreak,left_and_right([[idx_env(use,prop,localnum_label("209"),string_esc("A=s(s(s(s(s(s(0))))))"),string_esc("A=s(s(s(s(s(s(0))))))"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("210"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("average_charge(S,A)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("211"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl])),defassrt(check,[],"Test:",[[string_esc([]),tt(string_esc("average_charge(S,Arg2)")),string_esc([])],raw_nl],[],assrtprops([],[[item([]),em(string_esc("If the following properties hold at call time:"))],[[linebreak,left_and_right([[idx_env(use,prop,localnum_label("212"),string_esc("S=[[],[],[]]"),string_esc("S=[[],[],[]]"))],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("213"),string_esc("= /2"),string_esc("= /2"))],string_esc(")")]])]],raw_nl],[],[[linebreak,em(string_esc("then the following properties should hold globally:")),raw_nl],[[linebreak,left_and_right([[string_esc("Calls of the form "),var([string_esc("average_charge(S,Arg2)")]),string_esc(" "),string_esc("fail.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("214"),string_esc("fails/1"),string_esc("fails/1"))],string_esc(")")]])]],raw_nl]))]]]]),sp("1"),raw_nl]]),[],[],section_env([with_parent,level(2)],local_label("Documentation on imports"),string_esc("Documentation on imports"),[string_esc("This module has the following direct dependencies:"),itemize_env(minus,[nop,nop,nop,[item([]),em([string_esc("Internal (engine) modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("215"),string_esc("term_basic"),string_esc("term_basic")),string_esc(", ")],[idx_env(use,code,localnum_label("216"),string_esc("basiccontrol"),string_esc("basiccontrol")),string_esc(", ")],[idx_env(use,code,localnum_label("217"),string_esc("basic_props"),string_esc("basic_props")),string_esc(".")]],raw_nl]],[item([]),em([string_esc("Packages"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("218"),string_esc("pure"),string_esc("pure")),string_esc(", ")],[idx_env(use,code,localnum_label("219"),string_esc("initial"),string_esc("initial")),string_esc(", ")],[idx_env(use,code,localnum_label("220"),string_esc("condcomp"),string_esc("condcomp")),string_esc(", ")],[idx_env(use,code,localnum_label("221"),string_esc("assertions"),string_esc("assertions")),string_esc(", ")],[idx_env(use,code,localnum_label("222"),string_esc("assertions/assertions_basic"),string_esc("assertions/assertions_basic")),string_esc(", ")],[idx_env(use,code,localnum_label("223"),string_esc("regtypes"),string_esc("regtypes")),string_esc(".")]],raw_nl]]])])]])]).