section_env([file_top_section,pragmas([]),paper_opts(1,afourpaper),coversec([],[],[[string_esc("Eduardo Gil Alba, z170238")]],[],nop,nop,[]),level(0)],global_label("Pure Logic Programming: Practise 1"),[string_esc("Pure Logic Programming: Practise 1")],[show_toc(subparts),section_env([unnumbered,level(1),subfile(intro)],global_label("code"),string_esc("code"),[[],[raw_nl,[[section_env([level(2)],local_label("Introduction"),[string_esc("Introduction")],[string_esc(" "),string_esc("The task at hand involves validating representations of statically loaded surfaces with variable load values assigned to discrete points. To facilitate analysis, we adopt several simplifications. Firstly, we constrain charges to predefined values according to the following predicate: "),env_(verbatim,[raw_string("charge(+++++++).
charge(++++++).
charge(+++++).
charge(++++).
charge(+++).
charge(++).
charge(+).
charge(0).
")]),string_esc(" "),string_esc("Here, each charge is denoted by the number of '+' symbols, e.g., '++++' signifies a charge of four units. "),p([]),string_esc("Furthermore, we discretize the two-dimensional surface, conceptualizing it as a grid of cells where each cell can hold one of the predefined charge values. An illustrative example of such a surface is: "),codeblock("text","
   +++    +++++++    0      +    ++++    0
 +++++++    +++      0      +    ++++    0
   +++       0    +++++++   +     0     ++++
   +++    +++++++    0    ++++    +      0
+++++++      0      +++     +    ++++    0
   +++    +++++++   +++     +     0      +
 +++++++    +++      0      +    ++++    0"),string_esc(" "),string_esc("For representation purposes, we employ a list of lists. The inner lists delineate cells horizontally, while the outer list groups cells by rows, with each element representing a load value. Thus, the above surface is structured as follows: "),codeblock("text","
[ [ +++ , +++++++ , 0 , + , ++++ , 0 ],
[ +++++++ , +++ , 0 , + , ++++ , 0 ],
[ +++ , 0 , +++++++ , + , 0 , ++++ ],
[ +++ , +++++++ , 0 , ++++ , + , 0 ],
[ +++++++ , 0 , +++ , + , ++++ , 0 ],
[ +++ , +++++++ , +++ , + , 0 , + ],
[ +++++++ , +++ , 0 , + , ++++ , 0 ] ]"),string_esc(" "),string_esc("Surfaces can have an arbitrary number of cells in both dimensions. "),p([]),string_esc("In order to accomplish this, we define two types of surfaces, both containing load values. We establish "),idx_env(use,prop,localnum_label("0"),[string_esc("basic_surface/1")],[string_esc("basic_surface/1")]),string_esc(" "),string_esc("which must consist of at least one line, with each line containing at least one cell. It is defined by: "),env_(verbatim,[raw_string("basic_surface([L]) :-
    my_list(L).
basic_surface([L|S2]) :-
    my_list(L),
    basic_surface(S2).
")]),string_esc(" "),string_esc("Additionally, we define "),idx_env(use,prop,localnum_label("1"),[string_esc("surface/1")],[string_esc("surface/1")]),string_esc(" "),string_esc("as above but in addition must ensure that all lines possess the same number of cells. It is defined by: "),env_(verbatim,[raw_string("surface([L|L2]) :-
    basic_surface([L|L2]),
    my_length(L,Tam),
    surface_acc([L|L2],Tam).
")]),string_esc(" "),string_esc("As you can see, an auxiliary predicate has been employed, which accepts the size as a term. In each recursion, it verifies the length of the horizontal lines. "),env_(verbatim,[raw_string("surface_acc([L],Tam) :-
    my_length(L,Tam).
surface_acc([[H|T]|T2],Acc) :-
    my_length([H|T],NewAcc),
    equal(Acc,NewAcc),
    surface_acc(T2,NewAcc).
")]),string_esc(" "),p([]),section_env([level(3)],local_label("Some examples of use:"),[string_esc("Some examples of use:")],[string_esc(" "),env_(enumerate,[string_esc(" "),item([]),string_esc("Check if a "),idx_env(use,prop,localnum_label("2"),[string_esc("basic_surface/1")],[string_esc("basic_surface/1")]),string_esc(" "),string_esc("is correct: "),codeblock("text","

  ?- basic_surface([[+++,+++++++,0,+], 
              [+++++++,+++,0,+,++++], 
              [+++,0], 
              [+++,+++++++,0], 
              [+++++++,0,+++,+,++++], 
              [+++], 
              [+++++++,+++,0]]).

  yes
  ?-"),string_esc(" "),item([]),string_esc("Check if a "),idx_env(use,prop,localnum_label("3"),[string_esc("surface/1")],[string_esc("surface/1")]),string_esc(" "),string_esc("is correct: "),codeblock("text","
  ?- surface([[+++,+++++++,0,+,++++,0], 
              [+++++++,+++,0,+,++++,0], 
              [+++,0,+++++++,+,0,++++], 
              [+++,+++++++,0,++++,+,0], 
              [+++++++,0,+++,+,++++,0], 
              [+++,+++++++,+++,+,0,+], 
              [+++++++,+++,0,+,++++,0]]).

  yes
  ?-"),string_esc(" ")]),string_esc(" "),p([])])]),section_env([level(2)],local_label("Operations with surfaces"),[string_esc("Operations with surfaces")],[string_esc(" "),string_esc("We define certain operations that can be performed on surfaces."),p([]),section_env([level(3)],local_label("h_line(S,N,C)"),[string_esc("h_line(S,N,C)")],[string_esc(" "),var([string_esc("C")]),string_esc(" "),string_esc("is the "),var([string_esc("N")]),string_esc("th horizontal line of the surface "),var([string_esc("S")]),string_esc(" "),p([]),var([string_esc("N")]),string_esc(" "),string_esc("is a natural number in Peano notation.The horizontal lines are represented as lists with load values. To facilitate this objective, an auxiliary predicate has been used, tasked with extracting an element from a list. Specifically, it retrieves a list from within a list of lists."),p([]),section_env([level(4)],local_label("Examples"),[string_esc("Examples")],[string_esc(" "),env_(enumerate,[string_esc(" "),item([]),string_esc("Lines begin from s(0) : "),codeblock("text","
h_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], 0, L).

no
?-"),string_esc(" "),item([]),string_esc("Extract 4th horizontal line: "),codeblock("text","
h_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], s(s(s(s(0)))), L).

L = [+,+++,0] ? 
yes
?-"),string_esc(" "),item([]),string_esc("Returns position from line given: "),codeblock("text","
h_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], N, [+,+++,0]).

N = s(0) ? ;
N = s(s(0)) ? ;
N = s(s(s(s(0)))) ? ; 
yes
?-"),string_esc(" "),item([]),string_esc("Passing non-existing line: "),codeblock("text","
h_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], N, [++,+++++,++++]).

no
?-"),string_esc(" ")]),string_esc(" "),p([])])]),section_env([level(3)],local_label("v_line(S,N,C)"),[string_esc("v_line(S,N,C)")],[string_esc(" "),var([string_esc("C")]),string_esc(" "),string_esc("is the list of the Nth cells of all horizontal lines of the surface "),var([string_esc("S")]),string_esc(". "),p([]),var([string_esc("N")]),string_esc(" "),string_esc("is a natural number in Peano notation. Similarly to the aforementioned predicate, an auxiliary predicate has been used, tasked with extracting an element from a list. Specifically, it retrieves a list from within a list of lists. "),section_env([level(4)],local_label("Examples"),[string_esc("Examples")],[string_esc(" "),env_(enumerate,[string_esc(" "),item([]),string_esc("Lines begin from s(0) : "),codeblock("text","
v_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], 0, C).

no
?-"),string_esc(" "),item([]),string_esc("Extract 2nd vertical line: "),codeblock("text","
v_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], s(s(0)), C).

C = [+++,+++,0,+++,0,+,++] ? 
yes
?-"),string_esc(" "),item([]),string_esc("Returns position from line given: "),codeblock("text","
v_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], N, [0,0,++,0,++,++,0]).

N = s(s(s(0))) ? 
yes
?-"),string_esc(" "),item([]),string_esc("Passing non-existing line: "),codeblock("text","
v_line([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], N, [++,0,+,+++++,++++,++,0]).

no
?-"),string_esc(" ")]),string_esc(" "),p([])])]),section_env([level(3)],local_label("v_lines(S, C)"),[string_esc("v_lines(S, C)")],[string_esc(" "),var([string_esc("C")]),string_esc(" "),string_esc("is the list of vertical lines of cells on the surface "),var([string_esc("S")]),string_esc(". "),p([]),string_esc("It utilizes an auxiliary predicate which, during each recursion, extracts the vertical line and concatenates it to the final list. "),section_env([level(4)],local_label("Examples"),[string_esc("Examples")],[string_esc(" "),env_(enumerate,[string_esc(" "),item([]),string_esc("Extract all vertical lines: "),codeblock("text","
v_lines([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], C).

C = [[+,+,++,+,++,+,+],[+++,+++,0,+++,0,+,++],[0,0,++,0,++,++,0]] ?
yes
?-"),string_esc(" ")]),string_esc(" "),p([])])]),section_env([level(3)],local_label("total_charge(S,T)"),[string_esc("total_charge(S,T)")],[string_esc(" "),var([string_esc("T")]),string_esc(" "),string_esc("is the sum of all load values in the surface "),var([string_esc("S")]),string_esc(". "),p([]),string_esc("It employs an auxiliary predicate that utilizes another predicate to calculate the sum of all loads within a horizontal line, with each recursive step contributing to the total sum."),p([]),section_env([level(4)],local_label("Examples"),[string_esc("Examples")],[string_esc(" "),env_(enumerate,[string_esc(" "),item([]),string_esc("Calculates total charge: "),codeblock("text","
?- total_charge([[+,+++,0], 
              [+,+++,0], 
              [++,0,++], 
              [+,+++,0], 
              [++,0,++], 
              [+,+,++], 
              [+,++,0]], T).

T = s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))))))))))))))))) ?  
yes
?-"),string_esc(" "),item([]),string_esc("Check with "),idx_env(use,prop,localnum_label("4"),[string_esc("basic_surface/1")],[string_esc("basic_surface/1")]),string_esc(" "),string_esc("given: "),codeblock("text","
?- total_charge([[+++,+++++++,0,+], 
              [+++++++,+++,0,+,++++], 
              [+++,0], 
              [+++,+++++++,0], 
              [+++++++,0,+++,+,++++], 
              [+++], 
              [+++++++,+++,0]], T).
no
?-"),string_esc(" ")]),string_esc(" "),p([])])]),section_env([level(3)],local_label("average_charge(S,A)"),[string_esc("average_charge(S,A)")],[string_esc(" "),var([string_esc("A")]),string_esc(" "),string_esc("is the average of all load valuesin the surface "),var([string_esc("S")]),string_esc("."),p([]),string_esc("This entails summing all the loads and dividing by the total number of cells. The result must be rounded by truncation,, i.e. returning the natural prior. For this purpose, the aforementioned predicate calculates the total sum of the load values, along with an auxiliary predicate that computes the total number of elements in the surface. Additionally, an integer division predicate is employed. "),section_env([level(4)],local_label("Examples"),[string_esc("Examples")],[string_esc(" "),env_(enumerate,[string_esc(" "),p([]),item([]),string_esc("Calculates average charge from example: "),codeblock("text","
?- average_charge([[+++,+++++++,0,+,++++,0], 
              [+++++++,+++,0,+,++++,0], 
              [+++,0,+++++++,+,0,++++], 
              [+++,+++++++,0,++++,+,0], 
              [+++++++,0,+++,+,++++,0], 
              [+++,+++++++,+++,+,0,+], 
              [+++++++,+++,0,+,++++,0]], A).

A = s(s(0)) ? 
yes
?-"),string_esc(" "),p([]),item([]),string_esc("Surface given with wrong load values: "),codeblock("text","
?- average_charge([[3,7,0,1,4,0], 
              [7,3,0,1,4,0], 
              [3,0,7,1,0,4], 
              [3,7,0,4,1,0], 
              [7,0,3,1,4,0], 
              [3,7,3,1,0,1], 
              [7,3,0,1,4,0]], A).

no
?-"),string_esc(" ")])])])])]],linebreak],[section_env([with_parent,level(2)],local_label("Usage and interface"),string_esc("Usage and interface"),cartouche(itemize_env(bullet,[[item([]),bf([string_esc("Library usage"),string_esc(":")]),linebreak,tt(string_esc(":- use_module(/home/lumbalu/PROLOG/repo/PROLOG/Practica 1/code.pl)."))],[item([]),bf([string_esc("Exports"),string_esc(":")]),linebreak,itemize_env(minus,[[[item([]),em([string_esc("Predicates"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("5"),string_esc("author_data/4"),string_esc("author_data/4")),string_esc(", ")],[idx_env(use,code,localnum_label("6"),string_esc("my_length/2"),string_esc("my_length/2")),string_esc(", ")],[idx_env(use,code,localnum_label("7"),string_esc("get/3"),string_esc("get/3")),string_esc(", ")],[idx_env(use,code,localnum_label("8"),string_esc("my_append/3"),string_esc("my_append/3")),string_esc(", ")],[idx_env(use,code,localnum_label("9"),string_esc("f/2"),string_esc("f/2")),string_esc(", ")],[idx_env(use,code,localnum_label("10"),string_esc("equal/2"),string_esc("equal/2")),string_esc(", ")],[idx_env(use,code,localnum_label("11"),string_esc("my_plus/3"),string_esc("my_plus/3")),string_esc(", ")],[idx_env(use,code,localnum_label("12"),string_esc("my_minus/3"),string_esc("my_minus/3")),string_esc(", ")],[idx_env(use,code,localnum_label("13"),string_esc("my_less/2"),string_esc("my_less/2")),string_esc(", ")],[idx_env(use,code,localnum_label("14"),string_esc("div/3"),string_esc("div/3")),string_esc(", ")],[idx_env(use,code,localnum_label("15"),string_esc("surface_acc/2"),string_esc("surface_acc/2")),string_esc(", ")],[idx_env(use,code,localnum_label("16"),string_esc("h_line/3"),string_esc("h_line/3")),string_esc(", ")],[idx_env(use,code,localnum_label("17"),string_esc("v_line/3"),string_esc("v_line/3")),string_esc(", ")],[idx_env(use,code,localnum_label("18"),string_esc("v_lines/2"),string_esc("v_lines/2")),string_esc(", ")],[idx_env(use,code,localnum_label("19"),string_esc("v_lines_aux/3"),string_esc("v_lines_aux/3")),string_esc(", ")],[idx_env(use,code,localnum_label("20"),string_esc("h_sum/2"),string_esc("h_sum/2")),string_esc(", ")],[idx_env(use,code,localnum_label("21"),string_esc("total_charge/2"),string_esc("total_charge/2")),string_esc(", ")],[idx_env(use,code,localnum_label("22"),string_esc("total_charge_aux/2"),string_esc("total_charge_aux/2")),string_esc(", ")],[idx_env(use,code,localnum_label("23"),string_esc("total_cells/2"),string_esc("total_cells/2")),string_esc(", ")],[idx_env(use,code,localnum_label("24"),string_esc("average_charge/2"),string_esc("average_charge/2")),string_esc(".")]],raw_nl]],nop,[item([]),em([string_esc("Properties"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("25"),string_esc("charge/1"),string_esc("charge/1")),string_esc(", ")],[idx_env(use,code,localnum_label("26"),string_esc("my_list/1"),string_esc("my_list/1")),string_esc(", ")],[idx_env(use,code,localnum_label("27"),string_esc("nat_num/1"),string_esc("nat_num/1")),string_esc(", ")],[idx_env(use,code,localnum_label("28"),string_esc("basic_surface/1"),string_esc("basic_surface/1")),string_esc(", ")],[idx_env(use,code,localnum_label("29"),string_esc("surface/1"),string_esc("surface/1")),string_esc(".")]],raw_nl]],nop,nop,nop],nop])],nop,nop,nop,nop]))),[],[],section_env([with_parent,level(2)],local_label("Documentation on exports"),string_esc("Documentation on exports"),[[defpred(local_label("author_data/4"),pred,"PREDICATE",author_data/4,[],[[string_esc("Defines authors in Deliverit system.")],[[]]]),sp("1"),raw_nl],[defpred(local_label("charge/1"),prop,"PROPERTY",charge/1,[],[[string_esc("Defines possible load values. "),p([]),string_esc(" "),string_esc("It is defined as: "),env_(verbatim,[raw_string("charge(+++++++).
charge(++++++).
charge(+++++).
charge(++++).
charge(+++).
charge(++).
charge(+).
charge(0).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("charge(C)")),string_esc([])],raw_nl],[var([string_esc("C")]),string_esc(" "),string_esc("is a load value")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("my_list/1"),prop,"PROPERTY",my_list/1,[],[[string_esc("Defines a list with load values. "),p([]),string_esc("It is defined as: "),env_(verbatim,[raw_string("my_list([H]) :-
    charge(H).
my_list([H|T]) :-
    charge(H),
    my_list(T).
")]),string_esc(" "),p([]),string_esc("The predicate "),idx_env(use,pred,localnum_label("30"),[string_esc("my_list/1")],[string_esc("my_list/1")]),string_esc(" "),string_esc("is called recursively, checking that all elements are charges and that it is a list structure. ")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("my_list(L)")),string_esc([])],raw_nl],[var([string_esc("L")]),string_esc(" "),string_esc("is a list with load values.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("my_length/2"),pred,"PREDICATE",my_length/2,[],[[string_esc("Calculates the size of a list. It is defined by: "),env_(verbatim,[raw_string("my_length([],0).
my_length([_1|T],s(N)) :-
    my_length(T,N).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("my_length(L,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("L")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("31"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("32"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("get/3"),pred,"PREDICATE",get/3,[],[[string_esc("Extracts Nth element from a list. It is defined by: "),env_(verbatim,[raw_string("get([Elem|_1],s(0),Elem).
get([_1|Rest],s(Index),Elem) :-
    get(Rest,Index,Elem).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("get(L,I,E)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("L")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("33"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("I")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("34"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("E")]),string_esc(" "),string_esc("is a load value")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("35"),string_esc("charge/1"),string_esc("charge/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("my_append/3"),pred,"PREDICATE",my_append/3,[],[[string_esc("Concatenate two lists. It is defined by: "),env_(verbatim,[raw_string("my_append([],L,L).
my_append([X|Xs],Ys,[X|Zs]) :-
    my_append(Xs,Ys,Zs).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("my_append(L1,L2,R)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("L1")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("36"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("L2")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("37"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("R")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("38"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("f/2"),pred,"PREDICATE",f/2,[],[[string_esc("Define equivalences between load values and natural numbers in Peano notation. In order to be able to perform arithmetic operations. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("f(+++++++,s(s(s(s(s(s(s(0)))))))).
f(++++++,s(s(s(s(s(s(0))))))).
f(+++++,s(s(s(s(s(0)))))).
f(++++,s(s(s(s(0))))).
f(+++,s(s(s(0)))).
f(++,s(s(0))).
f(+,s(0)).
f(0,0).
f(s(s(s(s(s(s(s(0))))))),s(s(s(s(s(s(s(0)))))))).
f(s(s(s(s(s(s(0)))))),s(s(s(s(s(s(0))))))).
f(s(s(s(s(s(0))))),s(s(s(s(s(0)))))).
f(s(s(s(s(0)))),s(s(s(s(0))))).
f(s(s(s(0))),s(s(s(0)))).
f(s(s(0)),s(s(0))).
f(s(0),s(0)).
")])],[[defassrt(check,[],"Usage 1:",[[string_esc([]),tt(string_esc("f(C,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is a load value")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("39"),string_esc("charge/1"),string_esc("charge/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("40"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[])),defassrt(check,[],"Usage 2:",[[string_esc([]),tt(string_esc("f(N1,N2)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("N1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("41"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("42"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("nat_num/1"),prop,"PROPERTY",nat_num/1,[],[[string_esc("Defines natural numbers in Peano notation. "),p([]),string_esc(" "),string_esc("It is defined as: "),env_(verbatim,[raw_string("nat_num(0).
nat_num(s(X)) :-
    nat_num(X).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("nat_num(X)")),string_esc([])],raw_nl],[var([string_esc("X")]),string_esc(" "),string_esc("is a natural number.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("equal/2"),pred,"PREDICATE",equal/2,[],[[string_esc("Defines equality operator "),idx_env(use,op,localnum_label("43"),[string_esc("==")],[string_esc("==")]),string_esc(" "),string_esc("between two natural numbers in Peano notation. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("equal(0,0).
equal(s(N),s(N)) :-
    nat_num(N),
    equal(N,N).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("equal(N1,N2)")),string_esc([])],raw_nl],[idx_env(use,pred,localnum_label("44"),[string_esc("equal/2")],[string_esc("equal/2")]),string_esc(" "),string_esc("will be true if both numbers are equal")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("N1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("45"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("46"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("my_plus/3"),pred,"PREDICATE",my_plus/3,[],[[string_esc("Defines sum operator "),idx_env(use,op,localnum_label("47"),[string_esc("+")],[string_esc("+")]),string_esc(" "),string_esc("between two natural numbers in Peano notation. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("my_plus(0,Y,Y) :-
    nat_num(Y).
my_plus(s(X),Y,s(Z)) :-
    my_plus(X,Y,Z).
")]),string_esc(" "),p([]),string_esc("In case base, the sum of any number with 0, is the same number. The recursive call decrements the value of the first operand to 0, reaching case base, which assigns the second operand to the result and, when returning, increments the result as many times as recursive calls have been made. ")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("my_plus(Op1,Op2,Res)")),string_esc([])],raw_nl],[var([string_esc("Res")]),string_esc(" "),string_esc("is the sum of "),var([string_esc("Op1")]),string_esc(" "),string_esc("and "),var([string_esc("Op2")])],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Op2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("48"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Op1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("49"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Res")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("50"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("my_minus/3"),pred,"PREDICATE",my_minus/3,[],[[string_esc("Defines subtraction operator "),idx_env(use,op,localnum_label("51"),[string_esc("-")],[string_esc("-")]),string_esc(" "),string_esc("between two natural numbers in Peano notation, using "),idx_env(use,pred,localnum_label("52"),[string_esc("my_plus/3")],[string_esc("my_plus/3")]),string_esc(". "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("my_minus(X,Y,Z) :-
    my_plus(Z,Y,X).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("my_minus(Op2,Op1,Res)")),string_esc([])],raw_nl],[var([string_esc("Res")]),string_esc(" "),string_esc("is the difference between "),var([string_esc("Op2")]),string_esc(" "),string_esc("and "),var([string_esc("Op1")])],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Op2")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("53"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Op1")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("54"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Res")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("55"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("my_less/2"),pred,"PREDICATE",my_less/2,[],[[string_esc("Defines less than "),idx_env(use,op,localnum_label("56"),[string_esc(">")],[string_esc(">")]),string_esc(" "),string_esc("operator between two natural numbers in Peano notation. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("my_less(0,s(X)) :-
    nat_num(X).
my_less(s(X),s(Y)) :-
    my_less(X,Y).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("my_less(N,M)")),string_esc([])],raw_nl],[idx_env(use,pred,localnum_label("57"),[string_esc("my_less/2")],[string_esc("my_less/2")]),string_esc(" "),string_esc("will be true if "),var([string_esc("N")]),string_esc(" "),string_esc("my_less than "),var([string_esc("M")])],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("58"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("M")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("59"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("div/3"),pred,"PREDICATE",div/3,[],[[string_esc("Defines division "),idx_env(use,op,localnum_label("60"),[string_esc("/")],[string_esc("/")]),string_esc(" "),string_esc("between two natural numbers in Peano notation. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("div(0,_1,0).
div(X,Y,s(0)) :-
    my_minus(X,Y,Z),
    my_less(Z,Y).
div(X,Y,s(Q)) :-
    my_minus(X,Y,Z),
    div(Z,Y,Q).
")]),string_esc(" "),p([]),string_esc("Division is viewed as successive subtractions from the dividend until it becomes 0 or the remainder. ")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("div(Dividend,Divisor,Quotient)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("Dividend")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("61"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Divisor")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("62"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("Quotient")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("63"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("basic_surface/1"),prop,"PROPERTY",basic_surface/1,[],[[string_esc("Defines a surface of load values. "),p([]),env_(note,[string_esc(" "),bf([string_esc("Note:")]),string_esc(" "),idx_env(use,pred,localnum_label("64"),[string_esc("basic_surface/1")],[string_esc("basic_surface/1")]),string_esc(" "),string_esc("must contains at least one non-empty horizontal line. ")]),string_esc(" "),p([]),string_esc("It is defined as: "),env_(verbatim,[raw_string("basic_surface([L]) :-
    my_list(L).
basic_surface([L|S2]) :-
    my_list(L),
    basic_surface(S2).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("basic_surface(CellList)")),string_esc([])],raw_nl],[var([string_esc("CellList")]),string_esc(" "),string_esc("is a list of lists with load cells.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("surface/1"),prop,"PROPERTY",surface/1,[],[[string_esc("Defines a surface of load values, represented by a load value matrix. "),p([]),env_(note,[string_esc(" "),bf([string_esc("Note:")]),string_esc(" "),idx_env(use,pred,localnum_label("65"),[string_esc("surface/1")],[string_esc("surface/1")]),string_esc(" "),string_esc("must contains at least one non-empty horizontal line. ")]),string_esc(" "),p([]),string_esc("It is defined as: "),env_(verbatim,[raw_string("surface([L|L2]) :-
    basic_surface([L|L2]),
    my_length(L,Tam),
    surface_acc([L|L2],Tam).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("surface(CellMatrix)")),string_esc([])],raw_nl],[var([string_esc("CellMatrix")]),string_esc(" "),string_esc("is a load value matrix.")],assrtprops([],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("surface_acc/2"),pred,"PREDICATE",surface_acc/2,[],[[string_esc("Checks length in all horizontal lines. "),p([]),string_esc("It is defined by: ")],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("surface_acc(S,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("66"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("67"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("h_line/3"),pred,"PREDICATE",h_line/3,[],[[string_esc("Extracts Nth horizontal line from surface. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("h_line([L],s(0),L).
h_line(S,N,C) :-
    get(S,N,C),
    surface(S).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("h_line(S,N,R)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("68"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("69"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("R")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("70"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("v_line/3"),pred,"PREDICATE",v_line/3,[],[[string_esc("Extracts Nth vertical line from surface. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("v_line([Fila],Indice,[Elemento]) :-
    get(Fila,Indice,Elemento).
v_line([Fila|Filas],Indice,[Elemento|Columna]) :-
    get(Fila,Indice,Elemento),
    v_line(Filas,Indice,Columna).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("v_line(S,N,C)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("71"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("72"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("73"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("v_lines/2"),pred,"PREDICATE",v_lines/2,[],[[string_esc("Extracts all vertical lines from a surface. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("v_lines([L],L).
v_lines([L|S2],C) :-
    my_length(L,Tam),
    v_lines_aux([L|S2],Tam,C).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("v_lines(S,C)")),string_esc([])],raw_nl],[],assrtprops([],[[item([]),em(string_esc("The following properties should hold at call time:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("74"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])]],raw_nl],[[item([]),em(string_esc("The following properties should hold upon exit:"))],[[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("75"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])]],raw_nl],[]))]]]),sp("1"),raw_nl],[defpred(local_label("v_lines_aux/3"),pred,"PREDICATE",v_lines_aux/3,[],[[env_(verbatim,[raw_string("v_lines_aux(S,s(0),[C]) :-
    v_line(S,s(0),C).
v_lines_aux(S,s(Index),Resto) :-
    v_lines_aux(S,Index,NewResto),
    v_line(S,s(Index),Coln),
    my_append(NewResto,[Coln],Resto).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("v_lines_aux(S,T,C)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("76"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("77"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("C")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("78"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("h_sum/2"),pred,"PREDICATE",h_sum/2,[],[[string_esc("Sum elements of a horizontal line. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("h_sum([C],N) :-
    f(C,N).
h_sum([H|T],Suma) :-
    h_sum(T,SumaResto),
    f(H,N),
    my_plus(N,SumaResto,Suma).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("h_sum(R,T)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("R")]),string_esc(" "),string_esc("is a list with load values.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("79"),string_esc("my_list/1"),string_esc("my_list/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("80"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("total_charge/2"),pred,"PREDICATE",total_charge/2,[],[[string_esc("Sum all load values of a surface. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("total_charge(S,T) :-
    total_charge_aux(S,T),
    surface(S).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("total_charge(S,T)")),string_esc([])],raw_nl],[var([string_esc("T")]),string_esc(" "),string_esc("is the sum of all elements in a surface.")],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("81"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("82"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("total_charge_aux/2"),pred,"PREDICATE",total_charge_aux/2,[],[[env_(verbatim,[raw_string("total_charge_aux([],0).
total_charge_aux([L|S2],T) :-
    total_charge_aux(S2,SumaResto),
    h_sum(L,SumaFila),
    my_plus(SumaFila,SumaResto,T).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("total_charge_aux(S,T)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("83"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("T")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("84"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("total_cells/2"),pred,"PREDICATE",total_cells/2,[],[[string_esc("Calculates the number of elements of a surface. "),p([]),string_esc("It is defined by: "),env_(verbatim,[raw_string("total_cells([L],N) :-
    my_length(L,N).
total_cells([L|S2],Total) :-
    total_cells(S2,TotalResto),
    my_length(L,Esta),
    my_plus(Esta,TotalResto,Total).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("total_cells(S,N)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("85"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("N")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("86"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl],[defpred(local_label("average_charge/2"),pred,"PREDICATE",average_charge/2,[],[[string_esc("Calculates average load value from surface. "),p([]),string_esc(" "),string_esc("It is defined by: "),env_(verbatim,[raw_string("average_charge([[]],_1).
average_charge(S,A) :-
    total_charge(S,M),
    total_cells(S,T),
    div(M,T,A).
")])],[[defassrt(check,[],"Usage:",[[string_esc([]),tt(string_esc("average_charge(S,A)")),string_esc([])],raw_nl],[],assrtprops([[item([]),em(string_esc("Call and exit should be compatible with:"))],[[linebreak,left_and_right([[var([string_esc("S")]),string_esc(" "),string_esc("is a load value matrix.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("87"),string_esc("surface/1"),string_esc("surface/1"))],string_esc(")")]])],[linebreak,left_and_right([[var([string_esc("A")]),string_esc(" "),string_esc("is a natural number.")],raw_nl],[[],[string_esc(" ("),[idx_env(use,prop,localnum_label("88"),string_esc("nat_num/1"),string_esc("nat_num/1"))],string_esc(")")]])]],raw_nl],[],[],[]))]]]),sp("1"),raw_nl]]),[],[],section_env([with_parent,level(2)],local_label("Documentation on imports"),string_esc("Documentation on imports"),[string_esc("This module has the following direct dependencies:"),itemize_env(minus,[nop,nop,nop,[item([]),em([string_esc("Internal (engine) modules"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("89"),string_esc("term_basic"),string_esc("term_basic")),string_esc(", ")],[idx_env(use,code,localnum_label("90"),string_esc("basiccontrol"),string_esc("basiccontrol")),string_esc(", ")],[idx_env(use,code,localnum_label("91"),string_esc("basic_props"),string_esc("basic_props")),string_esc(".")]],raw_nl]],[item([]),em([string_esc("Packages"),string_esc(":")]),linebreak,[[[idx_env(use,code,localnum_label("92"),string_esc("pure"),string_esc("pure")),string_esc(", ")],[idx_env(use,code,localnum_label("93"),string_esc("initial"),string_esc("initial")),string_esc(", ")],[idx_env(use,code,localnum_label("94"),string_esc("condcomp"),string_esc("condcomp")),string_esc(", ")],[idx_env(use,code,localnum_label("95"),string_esc("assertions"),string_esc("assertions")),string_esc(", ")],[idx_env(use,code,localnum_label("96"),string_esc("assertions/assertions_basic"),string_esc("assertions/assertions_basic")),string_esc(", ")],[idx_env(use,code,localnum_label("97"),string_esc("regtypes"),string_esc("regtypes")),string_esc(".")]],raw_nl]]])])]])]).